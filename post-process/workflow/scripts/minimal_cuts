#!/usr/bin/env python3

import json
import argparse
from ete3 import Tree
import ete3
import os
import sys
from loguru import logger
import time
import re
from datetime import datetime
import multiprocessing


# Recursive function to compute the optimal costs, cuts, and colors at each node
def compute_costs(node, target_leaves, all_leaf_coloring=False):
    logger.debug("Processing node: {}", node.name)

    if node.is_leaf():
        logger.debug("Node {} is a leaf", node.name)

        if node.name in target_leaves:
            logger.debug("Node {} is a target red leaf", node.name)
            return (0, 0), (float("inf"), 0), [], []
        else:
            logger.debug("Node {} is a non-target blue leaf", node.name)
            return (float("inf"), 0), (0, 0), [], []

    else:
        logger.debug("Node {} is not a leaf. Evaluating children...",
                     node.name)

    red_cost, blue_cost = (0, 0), (0, 0)
    red_cuts, blue_cuts = [], []

    ambiguous_child = False
    # Loop through all children of the current node
    for child in node.children:
        logger.debug("Evaluating child node: {}", child.name)

        (
            child_red_cost,
            child_blue_cost,
            child_red_cuts,
            child_blue_cuts,
        ) = compute_costs(child, target_leaves, all_leaf_coloring)

        # Update the red and blue costs and cuts based on the child's costs
        if child_red_cost[0] <= child_blue_cost[0] + 1:
            red_cost = (
                red_cost[0] + child_red_cost[0],
                red_cost[1] + child_red_cost[1],
            )
            red_cuts.extend(child_red_cuts)
        else:
            red_cost = (red_cost[0] + child_blue_cost[0] + 1, red_cost[1] + 1)
            red_cuts.extend(child_blue_cuts)
            red_cuts.append(child.name)

        if child_blue_cost[0] <= child_red_cost[0] + 1:
            blue_cost = (
                blue_cost[0] + child_blue_cost[0],
                blue_cost[1] + child_blue_cost[1],
            )
            blue_cuts.extend(child_blue_cuts)
        else:
            blue_cost = (blue_cost[0] + child_red_cost[0] + 1,
                         blue_cost[1] + 1)
            blue_cuts.extend(child_red_cuts)
            blue_cuts.append(child.name)

        logger.debug(
            "Computed costs for node {}: Red Cost = {}, Blue Cost = {}",
            node.name,
            red_cost,
            blue_cost,
        )

    return red_cost, blue_cost, red_cuts, blue_cuts


def backtrack_and_recolor(root_color, tree, cuts):
    # Convert the cuts list to a set for efficient lookups
    cuts_set = set(cuts)

    for node in tree.traverse("levelorder"):
        logger.debug("Node: {}", node.name)
        if node == tree:
            node.add_features(color=root_color)
            continue
        parent_color = node.up.color
        logger.debug("Parent's color: {}", parent_color)
        child_color = parent_color
        if node.name in cuts_set:
            logger.debug("Cut found! Switching child's color")
            if parent_color == "red":
                child_color = "blue"
            else:
                child_color = "red"
        logger.debug("Child's color: {}", child_color)
        node.add_features(color=child_color)

    # Build the result dictionary
    color_dict = {
        node.name: node.color
        for node in tree.traverse() if node.name
    }

    return color_dict


# Read target leaf set as chunks
def read_target_leaves(file_path, chunk_size):

    def generate_chunks():
        with open(file_path, "r") as f:
            chunk = []
            for line in f:
                stripped_line = line.strip()
                if stripped_line:
                    chunk.append(set(stripped_line.split()))
                    if len(chunk) == chunk_size:
                        yield chunk
                        chunk = []
            if chunk:
                yield chunk

    return generate_chunks()


# def read_target_leaves(file_path):
# with open(file_path, "r") as f:
# Split each line by whitespace and store as a set in the list
# return [set(line.strip().split()) for line in f if line.strip()]
"""
Code copied from Prophyle:
    https://github.com/prophyle/prophyle/blob/50419f0c551f03eb6a3163f32cbc14713cd1a9bb/prophyle/prophyle_propagation_preprocessing.py#L43
"""


def autocomplete_internal_node_names(tree, newtreefile):
    logger.info("Autocompleting internal node names")

    re_inferred = re.compile(r"^(.*)-up(\d+)$")

    renamed_nodes = False
    for n in tree.traverse("postorder"):
        if len(n.children) == 0:
            assert hasattr(n, "name")
        else:
            for x in n.children:
                assert hasattr(x, "name")

            if not hasattr(n, "name") or n.name == "" or n.name is None:
                names = [x.name for x in n.children]
                lmin_name = sorted(names)[0]

                m = re_inferred.match(lmin_name)
                if m is not None:
                    left, right = m.groups()
                    right = int(right) + 1
                    n.name = "{}-up{}".format(left, right)
                else:
                    n.name = lmin_name + "-up1"
                logger.debug("Named node {}", n.name)
                renamed_nodes = True
    if renamed_nodes:
        logger.info("Renamed internal nodes! Outputting new tree to {}",
                    newtreefile)
        tree.write(format=1, outfile=newtreefile)
    return tree


def process_chunk(tree, chunk_data, all_leaf_coloring):
    results = []
    colors_info = []

    for num, target_leaves in enumerate(chunk_data):
        logger.debug("Processing leaf set - %s" % num)
        logger.debug("Target leaves are %s" % target_leaves)

        start_time = time.time()
        (
            root_red_cost,
            root_blue_cost,
            root_red_cuts,
            root_blue_cuts,
        ) = compute_costs(tree, target_leaves, all_leaf_coloring)

        # Determine the optimal color for the root
        if root_red_cost[0] < root_blue_cost[0]:
            best_cuts = root_red_cuts
            root_decision = "red"
        elif root_blue_cost[0] < root_red_cost[0]:
            best_cuts = root_blue_cuts
            root_decision = "blue"
        else:
            best_cuts = (root_red_cuts, root_blue_cuts)
            root_decision = "ambiguous"

        results.append(best_cuts)

        if all_leaf_coloring:
            logger.info("Backtracking to color internal nodes...")
            # Call the backtracking function
            if root_decision != "ambiguous":
                optimal_colors = backtrack_and_recolor(root_decision, tree,
                                                       best_cuts)
            else:
                optimal_colors_red = backtrack_and_recolor(
                    "red", tree, best_cuts[0])
                optimal_colors_blue = backtrack_and_recolor(
                    "blue", tree, best_cuts[1])
                optimal_colors = (optimal_colors_red, optimal_colors_blue)

            # Store a tuple with the set number, the chosen color for the set, and the color mapping
            colors_info.append((num, root_decision, optimal_colors))

        end_time = time.time()
        elapsed_time = end_time - start_time

        logger.info("Took {:.2f} seconds.", elapsed_time)

    return results, colors_info


def minimal_cuts_for_all_sets(tree,
                              leaves_file_path,
                              chunk_size,
                              num_threads,
                              all_leaf_coloring=False):
    pool = multiprocessing.Pool(num_threads)
    results = []
    colors_info = [
    ]  # To store the coloring information for each set of target leaves

    tasks = [(tree, chunk, all_leaf_coloring)
             for chunk in read_target_leaves(leaves_file_path, chunk_size)]

    # Map tasks to the pool of processes
    processed_chunks = pool.starmap(process_chunk, tasks)

    # Combine results from all chunks
    for chunk_results, chunk_colors in processed_chunks:
        results.extend(chunk_results)
        colors_info.extend(chunk_colors)

    pool.close()
    pool.join()

    return results, colors_info if all_leaf_coloring else results


#    for chunk in read_target_leaves(leaves_file_path, chunk_size):
#        for num, target_leaves in enumerate(chunk):
#            logger.info("Processing leaf set - %s" % num)
#            logger.debug("Target leaves are %s" % target_leaves)
#
#            start_time = time.time()
#            (
#                root_red_cost,
#                root_blue_cost,
#                root_red_cuts,
#                root_blue_cuts,
#            ) = compute_costs(tree, target_leaves, all_leaf_coloring)
#
#            # Determine the optimal color for the root
#            if root_red_cost[0] < root_blue_cost[0]:
#                best_cuts = root_red_cuts
#                root_decision = "red"
#            elif root_blue_cost[0] < root_red_cost[0]:
#                best_cuts = root_blue_cuts
#                root_decision = "blue"
#            else:
#                best_cuts = (root_red_cuts, root_blue_cuts)
#                root_decision = "ambiguous"
#
#            results.append(best_cuts)
#
#            if all_leaf_coloring:
#                logger.info("Backtracking to color internal nodes...")
#                # Call the backtracking function
#                if root_decision != "ambiguous":
#                    optimal_colors = backtrack_and_recolor(
#                        root_decision, tree, best_cuts
#                    )
#                else:
#                    optimal_colors_red = backtrack_and_recolor("red", tree, best_cuts[0])
#                    optimal_colors_blue = backtrack_and_recolor("blue", tree, best_cuts[1])
#                    optimal_colors = (optimal_colors_red, optimal_colors_blue)
#
#                # Store a tuple with the set number, the chosen color for the set, and the color mapping
#                colors_info.append((num, root_decision, optimal_colors))
#
#            end_time = time.time()
#            elapsed_time = end_time - start_time
#
#            logger.info("Took {:.2f} seconds.", elapsed_time)
#
#    return results, colors_info if all_leaf_coloring else results


def write_output(data, output_file=None):
    if output_file:
        with open(output_file, "w") as f:
            f.write(str(data))
    else:
        print(data)


def plot_tree_and_colors(tree, color_dict, output):
    os.environ["QT_QPA_PLATFORM"] = "offscreen"
    logger.debug("Saving tree to {}", output)

    ts = ete3.TreeStyle()

    def label_nodes(node, color_dict):
        # Set default color to black
        node_color = "#000000"  # black

        # Check the color from the dictionary
        if node.name in color_dict:
            if color_dict[node.name] == "red":
                node_color = "#FF0000"  # red
            elif color_dict[node.name] == "blue":
                node_color = "#0000FF"  # blue
            elif color_dict[node.name] == "purple":
                node_color = "#800080"  # purple

        node.img_style["hz_line_color"] = node_color
        node.img_style["vt_line_color"] = node_color

        if node.is_leaf():
            if hasattr(node, "color_face"):
                # Update the existing face's color
                node.color_face.bgcolor = node_color
                node.color_face.fgcolor = node_color
            else:
                name_face = ete3.faces.TextFace(node.name,
                                                tight_text=False,
                                                fsize=10)
                node.add_face(name_face, column=0, position="aligned")
                # Create a new face if it doesn't exist
                rect_face = ete3.faces.RectFace(width=10,
                                                height=10,
                                                fgcolor=node_color,
                                                bgcolor=node_color)
                node.add_face(rect_face, column=1, position="aligned")
                # Store the face in a custom attribute for later reference
                node.color_face = rect_face

        # Sets the style of internal nodes
        node.img_style["size"] = 10
        node.img_style["fgcolor"] = node_color

    # Remove default labels
    ts.show_leaf_name = False

    # Modify the layout function to accept a color dictionary
    def custom_layout(node):
        label_nodes(node, color_dict)

    ts.layout_fn = custom_layout
    ts.draw_guiding_lines = True
    tree.render(output, tree_style=ts)


def main():
    parser = argparse.ArgumentParser(
        description="Compute minimal cuts for coloring a tree.")
    parser.add_argument("tree_file",
                        type=str,
                        help="Path to the Newick formatted tree file.")
    parser.add_argument(
        "leaves_file",
        type=str,
        help="Path to the file containing target (red) leaves.")
    parser.add_argument(
        "--all",
        dest="all_solutions",
        action="store_true",
        help=
        "Return all solutions if both red and blue colorings have the same cost.",
    )
    parser.add_argument(
        "-t",
        "--tree",
        type=str,
        default=
        f"./minimalcuts_fullynamedtree_{datetime.now().strftime('%Y-%m-%d-%H:%M:%S')}.nwk",
        help=
        "Path to new tree file if internal nodes need to be renamed. If not \
        provided and internal nodes do need renaming, then new tree is saved to \
        './minimalcuts_fullynamedtree_YYYY-MM-DD-HH:mm:ss.nwk'",
    )
    parser.add_argument(
        "-o",
        "--output",
        type=str,
        default=None,
        help=
        "Path to output file. If not provided, output will be printed to stdout.",
    )
    parser.add_argument(
        "-c",
        "--colors",
        type=str,
        default=None,
        help=
        "If specified, also output node colors for every leaf subset in leaves_file to this file.",
    )
    parser.add_argument(
        "-p",
        "--plot",
        dest="plot",
        type=str,
        default=None,
        help="Plot solutions using ete3 and save plots to specified directory.",
    )
    parser.add_argument(
        "-j",
        "--threads",
        default=multiprocessing.cpu_count(),
        type=int,
        help="Number of threads to use. Default is all available.",
    )
    parser.add_argument(
        "-cs",
        "--chunksize",
        default=5000,
        type=int,
        help=
        "How many leaf sets to analyze at once in parallel. Default is 5,000.",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help=
        "Increase verbosity level. Can be specified multiple times for more detailed logs.",
    )

    args = parser.parse_args()

    if args.verbose == 0:
        logger.remove()
    elif args.verbose == 1:
        logger.remove()
        logger.add(sys.stderr, level="INFO")
    elif args.verbose >= 2:
        logger.remove()
        logger.add(sys.stderr, level="DEBUG")

    tree = Tree(args.tree_file, format=1)
    tree = autocomplete_internal_node_names(tree, args.tree)

    # all_target_leaves = read_target_leaves(args.leaves_file)
    results, colors = minimal_cuts_for_all_sets(tree, args.leaves_file,
                                                args.chunksize, args.threads,
                                                args.colors)

    # Write minimal cuts results to output or stdout
    output_file = args.output if args.output else sys.stdout
    logger.info("Outputting cuts to {}", output_file)
    with open(output_file, "w") if args.output else sys.stdout as out:
        for result in results:
            if isinstance(result,
                          tuple) and args.all_solutions:  # Two solutions exist
                out.write(",".join(result[0]) + " OR " + ",".join(result[1]) +
                          "\n")
            elif isinstance(result, tuple):
                out.write(",".join(result[0]) + "\n")
            else:
                out.write(",".join(result) + "\n")

    # Write coloring output also
    if args.colors:
        logger.info("Outputting all node coloring to to {}", args.colors)
        with open(args.colors, "w") as out_colors:
            for color in colors:
                colordict = color[2]
                if isinstance(colordict, tuple):
                    if args.all_solutions:
                        out_colors.write(
                            str(colordict[0]) + " OR " + str(colordict[1]) +
                            "\n")
                    else:
                        out_colors.write(str(colordict[0]) + "\n")
                else:
                    out_colors.write(str(colordict) + "\n")
        # plot trees
        if args.plot:
            for color in colors:
                colordict = color[2]
                if isinstance(colordict, tuple):
                    if args.all_solutions:
                        output = os.path.join(
                            args.plot, "leafset-%s-solution1.svg" % color[0])
                        plot_tree_and_colors(tree, colordict[0], output)
                        output = os.path.join(
                            args.plot, "leafset-%s-solution2.svg" % color[0])
                        plot_tree_and_colors(tree, colordict[1], output)
                    else:
                        output = os.path.join(
                            args.plot, "leafset-%s-solution1.svg" % color[0])
                        plot_tree_and_colors(tree, colordict[0], output)
                else:
                    output = os.path.join(args.plot,
                                          "leafset-%s-solution.svg" % color[0])
                    plot_tree_and_colors(tree, colordict, output)


if __name__ == "__main__":
    main()
