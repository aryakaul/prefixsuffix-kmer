#!/usr/bin/env python

import pandas as pd
import sys
import argparse
import re
from loguru import logger
import os
import seaborn as sns
from ete3 import Tree
"""
Code copied from Prophyle:
    https://github.com/prophyle/prophyle/blob/50419f0c551f03eb6a3163f32cbc14713cd1a9bb/prophyle/prophyle_propagation_preprocessing.py#L43
"""


def is_float(string):
    try:
        float(string)
        return True
    except ValueError:
        return False


def autocomplete_internal_node_names(tree):
    logger.info("Autocompleting internal node names")

    re_inferred = re.compile(r"^(.*)-up(\d+)$")

    renamed_nodes = False
    for n in tree.traverse("postorder"):
        if len(n.children) == 0:
            assert hasattr(n, "name")
        else:
            for x in n.children:
                assert hasattr(x, "name")

            if not hasattr(
                    n, "name") or n.name == "" or n.name is None or is_float(
                        n.name):
                names = [x.name for x in n.children]
                lmin_name = sorted(names)[0]

                m = re_inferred.match(lmin_name)
                if m is not None:
                    left, right = m.groups()
                    right = int(right) + 1
                    n.name = "{}-up{}".format(left, right)
                else:
                    n.name = lmin_name + "-up1"
                logger.debug("Named node {}", n.name)
                renamed_nodes = True
    if renamed_nodes:
        logger.info("Renamed internal nodes!")
    return tree


def assign_cluster_colors(labels):
    # Sort unique labels, ensuring -1 is last
    unique_labels = sorted(set(labels), key=lambda x: (x == -1, x))
    logger.debug(f"Sorted Labels: {unique_labels}")

    # Get colors from the seaborn muted palette
    n_colors = len(unique_labels)
    logger.debug(f"Number of colors: {n_colors}")

    # Generate a color palette with enough distinct colors
    base_palette = sns.color_palette("muted", as_cmap=False).as_hex()
    if n_colors > len(base_palette):
        logger.warning(
            f"{n_colors} is more than in the seaborn palette. Adding new colors with different brightness."
        )
        extended_palette = base_palette + sns.color_palette(
            "muted", n_colors - len(base_palette), desat=0.6).as_hex()
    else:
        extended_palette = base_palette

    colors = extended_palette[:n_colors]
    logger.debug(f"Available colors: {colors}")

    # Initialize label_color_map with regular clusters
    label_color_map = {
        label: colors[i]
        for i, label in enumerate(unique_labels) if label != -1
    }

    # If -1 is in labels, assign it the last color from the palette
    if -1 in unique_labels:
        label_color_map[-1] = colors[
            -1]  # Assigning the last color in the palette to -1

    return label_color_map


def assign_internalnodes(node, attr_name):
    if node.is_leaf():
        return getattr(node, attr_name)
    else:
        child_values = set(
            assign_internalnodes(child, attr_name) for child in node.children)
        if len(child_values) == 1:
            node_value = child_values.pop(
            )  # All children have the same value for the attribute
        else:
            node_value = "NaN"  # Children have different values for the attribute

        setattr(node, attr_name, node_value)
        return node_value


def create_colorrange_annots(tree, outfile, cluster_to_color):
    itol_dataset_lines = [
        "DATASET_RANGE", "SEPARATOR COMMA", "DATASET_LABEL,Cluster",
        "COLOR,#ffff00", "DATA"
    ]

    def process_node(node, parent_cluster=None):
        logger.debug(
            f"Node: {node.name} Parent Cluster: {parent_cluster} Node Cluster: {node.cluster}"
        )

        if str(node.cluster) != 'NaN' and node.cluster != parent_cluster:
            logger.debug(f"Appended node to data file.")
            itol_dataset_lines.append(
                f"{node.name},{node.name},{cluster_to_color[node.cluster]},,,,,{node.cluster}"
            )

        # Process children, but pass 'NaN' if current node's color is 'NaN'
        new_parent_cluster = node.cluster if str(
            node.cluster) != 'NaN' else parent_cluster
        for child in node.children:
            process_node(child, new_parent_cluster)

    # Start processing from the root
    process_node(tree)

    with open(outfile, "w") as f:
        f.write("\n".join(itol_dataset_lines))


def create_bracketrange_annots(tree, outfile, attr, vals):
    itol_dataset_lines = [
        "DATASET_RANGE", "SEPARATOR COMMA", f"DATASET_LABEL,{attr}",
        "COLOR,#000000", "RANGE_TYPE,box", "LABEL_SIZE_FACTOR,5",
        "BRACKET_STYLE,square", "SHOW_LABELS,1", "DATA"
    ]

    palette = sns.color_palette("husl", len(vals)).as_hex()
    attr_map = {label: palette[i] for i, label in enumerate(vals)}

    def process_node(node, parent_attr=None):
        node_attr = str(getattr(node, attr))
        logger.debug(
            f"Node: {node.name} Parent Cluster: {parent_attr} Node {attr}: {node_attr}"
        )

        if node_attr != 'NaN' and node_attr != parent_attr:
            logger.debug(f"Appended node to data file.")
            itol_dataset_lines.append(
                f"{node.name},{node.name},{attr_map[node_attr]},,{attr_map[node_attr]},solid,3,{node_attr},,,"
            )

        # Process children, but pass 'NaN' if current node's color is 'NaN'
        new_parent_attr = node_attr if node_attr != 'NaN' else parent_attr
        for child in node.children:
            process_node(child, new_parent_attr)

    # Start processing from the root
    process_node(tree)

    with open(outfile, "w") as f:
        f.write("\n".join(itol_dataset_lines))


def create_simplebar_annots(df, outfile):
    itol_dataset_lines = [
        "DATASET_SIMPLEBAR", "SEPARATOR COMMA",
        "DATASET_LABEL,Difference (bp)", "COLOR,#0000ff", "DATA"
    ]
    for row in df.itertuples():
        label = row.GenomeID
        difference = row.Difference
        itol_dataset_lines.append(f"{label},{difference}")
    with open(outfile, "w") as f:
        f.write("\n".join(itol_dataset_lines))


def main():
    parser = argparse.ArgumentParser(
        description="Create iTOL dataset annotations")
    parser.add_argument(
        "-i",
        "--inputcsv",
        type=str,
        required=True,
        help="Input CSV output for a passing gene",
    )
    parser.add_argument(
        "-t",
        "--tree",
        type=str,
        required=True,
        help="Input newick tree to visualize",
    )
    parser.add_argument(
        "-o",
        "--outdir",
        type=str,
        required=True,
        help="Path to the output directory",
    )
    parser.add_argument(
        "-m",
        "--metadatataxonomy",
        type=str,
        required=False,
        help="Path to the taxonomy data (output of kraken)",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help=
        "Increase verbosity level. Can be specified multiple times for more detailed logs.",
    )

    args = parser.parse_args()
    os.makedirs(args.outdir, exist_ok=True)

    if args.verbose == 0:
        logger.remove()
    elif args.verbose == 1:
        logger.remove()
        logger.add(sys.stderr, level="INFO")
    elif args.verbose >= 2:
        logger.remove()
        logger.add(sys.stderr, level="DEBUG")

    logger.info("Reading input csv")
    df = pd.read_csv(args.inputcsv)
    tree = Tree(args.tree, format=1)
    tree = autocomplete_internal_node_names(tree)
    tree.write(format=1,
               outfile=os.path.join(args.outdir,
                                    os.path.basename(args.outdir) + ".nwk"))

    id_to_cluster = dict(zip(df['GenomeID'], df['Cluster']))
    for leaf in tree:
        cluster_val = id_to_cluster[leaf.name]
        leaf.cluster = cluster_val
        logger.debug(f"Leaf: {leaf.name} Cluster: {leaf.cluster}")

    root_cluster = assign_internalnodes(tree, 'cluster')
    logger.info("Clusters assigned to internal nodes")

    color_pal = assign_cluster_colors(df['Cluster'])
    logger.debug(f"Color palette: {color_pal}")
    create_colorrange_annots(tree, os.path.join(args.outdir,
                                                "colorrange.annot"), color_pal)
    if args.metadatataxonomy:
        sp_mapping = pd.read_csv(args.metadatataxonomy, sep='\t')
        sp_mapping.fillna('None', inplace=True)
        columns_to_add = [
            'major_species', 'phylum', 'class', 'order', 'family', 'genus',
            'species'
        ]
        df_merged = pd.merge(df,
                             sp_mapping[columns_to_add + ['sample_id']],
                             left_on='GenomeID',
                             right_on='sample_id',
                             how='left')
        df_merged.drop('sample_id', axis=1, inplace=True)
        df = df_merged
        for c in columns_to_add:
            logger.debug(f"Adding {c} to leaf labels")
            id_to_c = dict(zip(df['GenomeID'], df[c]))
            for leaf in tree:
                c_val = id_to_c[leaf.name]
                logger.debug(f"Leaf: {leaf.name} {c}: {c_val}")
                setattr(leaf, c, c_val)
            assign_internalnodes(tree, c)
            vals = df[c].unique()
            create_bracketrange_annots(
                tree, os.path.join(args.outdir, f"{c}-range.annot"), c, vals)

    create_simplebar_annots(df, os.path.join(args.outdir, "simplebar.annot"))
    logger.success("Created annotation files successfully")


if __name__ == "__main__":
    main()
