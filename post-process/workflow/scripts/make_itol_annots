#!/usr/bin/env python

import pandas as pd
import sys
import argparse
import re
from loguru import logger
import os
import seaborn as sns
from ete3 import Tree
"""
Code copied from Prophyle:
    https://github.com/prophyle/prophyle/blob/50419f0c551f03eb6a3163f32cbc14713cd1a9bb/prophyle/prophyle_propagation_preprocessing.py#L43
"""


def autocomplete_internal_node_names(tree):
    logger.info("Autocompleting internal node names")

    re_inferred = re.compile(r"^(.*)-up(\d+)$")

    renamed_nodes = False
    for n in tree.traverse("postorder"):
        if len(n.children) == 0:
            assert hasattr(n, "name")
        else:
            for x in n.children:
                assert hasattr(x, "name")

            if not hasattr(n, "name") or n.name == "" or n.name is None:
                names = [x.name for x in n.children]
                lmin_name = sorted(names)[0]

                m = re_inferred.match(lmin_name)
                if m is not None:
                    left, right = m.groups()
                    right = int(right) + 1
                    n.name = "{}-up{}".format(left, right)
                else:
                    n.name = lmin_name + "-up1"
                logger.debug("Named node {}", n.name)
                renamed_nodes = True
    if renamed_nodes:
        logger.info("Renamed internal nodes!")
    return tree


def assign_cluster_colors(labels):
    # Sort unique labels, ensuring -1 is last
    unique_labels = sorted(set(labels), key=lambda x: (x == -1, x))
    logger.debug(f"Sorted Labels: {unique_labels}")

    # Get colors from the seaborn muted palette
    n_colors = len(unique_labels)
    logger.debug(f"Number of colors: {n_colors}")

    # Generate a color palette with enough distinct colors
    base_palette = sns.color_palette("muted", as_cmap=False).as_hex()
    if n_colors > len(base_palette):
        logger.warning(
            f"{n_colors} is more than in the seaborn palette. Adding new colors with different brightness."
        )
        extended_palette = base_palette + sns.color_palette(
            "muted", n_colors - len(base_palette), desat=0.6).as_hex()
    else:
        extended_palette = base_palette

    colors = extended_palette[:n_colors]
    logger.debug(f"Available colors: {colors}")

    # Initialize label_color_map with regular clusters
    label_color_map = {
        label: colors[i]
        for i, label in enumerate(unique_labels) if label != -1
    }

    # If -1 is in labels, assign it the last color from the palette
    if -1 in unique_labels:
        label_color_map[-1] = colors[
            -1]  # Assigning the last color in the palette to -1

    return label_color_map


def cluster_internalnodes(node):
    if node.is_leaf():
        return node.cluster
    else:
        child_clusters = set(
            cluster_internalnodes(child) for child in node.children)
        if len(child_clusters) == 1:
            node_cluster = child_clusters.pop(
            )  # All children have the same cluster
        else:
            node_cluster = "NaN"  # Children have different clusters

        node.cluster = node_cluster
        return node_cluster


def create_colorrange_annots(tree, outfile, cluster_to_color):
    itol_dataset_lines = [
        "DATASET_RANGE", "SEPARATOR COMMA", "DATASET_LABEL,Cluster",
        "COLOR,#ffff00", "DATA"
    ]

    def process_node(node, parent_cluster=None):
        logger.debug(
            f"Node: {node.name} Parent Cluster: {parent_cluster} Node Cluster: {node.cluster}"
        )

        if str(node.cluster) != 'NaN' and node.cluster != parent_cluster:
            logger.debug(f"Appended node to data file.")
            itol_dataset_lines.append(
                f"{node.name},{node.name},{cluster_to_color[node.cluster]},,,,,{node.cluster}"
            )

        # Process children, but pass 'NaN' if current node's color is 'NaN'
        new_parent_cluster = node.cluster if str(
            node.cluster) != 'NaN' else parent_cluster
        for child in node.children:
            process_node(child, new_parent_cluster)

    # Start processing from the root
    process_node(tree)

    with open(outfile, "w") as f:
        f.write("\n".join(itol_dataset_lines))


def create_simplebar_annots(df, outfile):
    itol_dataset_lines = [
        "DATASET_SIMPLEBAR", "SEPARATOR COMMA",
        "DATASET_LABEL,Difference (bp)", "COLOR,#0000ff", "DATA"
    ]
    for row in df.itertuples():
        label = row.GenomeID
        difference = row.Difference
        itol_dataset_lines.append(f"{label},{difference}")
    with open(outfile, "w") as f:
        f.write("\n".join(itol_dataset_lines))


def main():
    parser = argparse.ArgumentParser(
        description="Create iTOL dataset annotations")
    parser.add_argument(
        "-i",
        "--inputcsv",
        type=str,
        required=True,
        help="Input CSV output for a passing gene",
    )
    parser.add_argument(
        "-t",
        "--tree",
        type=str,
        required=True,
        help="Input newick tree to visualize",
    )
    parser.add_argument(
        "-o",
        "--outdir",
        type=str,
        required=True,
        help="Path to the output directory",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help=
        "Increase verbosity level. Can be specified multiple times for more detailed logs.",
    )

    args = parser.parse_args()
    os.makedirs(args.outdir, exist_ok=True)

    if args.verbose == 0:
        logger.remove()
    elif args.verbose == 1:
        logger.remove()
        logger.add(sys.stderr, level="INFO")
    elif args.verbose >= 2:
        logger.remove()
        logger.add(sys.stderr, level="DEBUG")

    logger.info("Reading input csv")
    df = pd.read_csv(args.inputcsv)
    tree = Tree(args.tree, format=1)
    tree = autocomplete_internal_node_names(tree)
    tree.write(format=1,
               outfile=os.path.join(args.outdir,
                                    os.path.basename(args.outdir) + ".nwk"))

    id_to_cluster = dict(zip(df['GenomeID'], df['Cluster']))
    for node in tree.traverse():
        if node.is_leaf():
            node.cluster = id_to_cluster[node.name]
            logger.debug(f"Leaf: {node.name} Cluster: {node.cluster}")

    root_cluster = cluster_internalnodes(tree)
    logger.info("Clusters assigned to internal nodes")

    color_pal = assign_cluster_colors(df['Cluster'])
    # unique_clusters = df['Cluster'].unique()
    # colors = sns.color_palette("muted", n_colors=len(unique_clusters)).as_hex()
    # color_pal = dict(zip(unique_clusters, colors))
    logger.debug(f"Color palette: {color_pal}")
    create_colorrange_annots(tree, os.path.join(args.outdir,
                                                "colorrange.annot"), color_pal)
    create_simplebar_annots(df, os.path.join(args.outdir, "simplebar.annot"))
    logger.success("Created annotation files successfully")


if __name__ == "__main__":
    main()
